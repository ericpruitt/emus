#!/usr/bin/awk -f

# Usage: git blame-colorizer [ANNOTATION_MODE] [OPTIONS] FILE
#
# The annotation mode controls what information is displayed in the margin. It
# can be "who", "what" (default) or "when".
#
# Options:
#   -m, --margin=COLUMNS
#                   Set the width of the commit summary margin.
#   -N              Hide working-copy line numbers.
#   -n, --show-number
#                   Show line numbers from the original commit.
#   -p, --porcelain
#                   Run "git blame --porcelain" without post-processing. Any
#                   flags specific to this script are silently ignored while
#                   any that mirror git-blame arguments are forwarded.
#   --palette=NAME  Set the color palette. For a list of palettes, search for
#                   "Predefined Color Palettes" in the AWK script source.
#   -s, --short     Show summaries using one line instead of two.
#   -u, --utc       Display commit times in UTC.
#   -y, --time=TYPE
#                   Controls how dates and times are displayed. This can be
#                   "host" (default) to indicate they should be displayed using
#                   the host's timezone, "author" for the author's time zone or
#                   "utc" for UTC.
#
# Any unrecognized arguments will be passed to git-blame.
#
# Bugs:
#    The "host" option is not locale aware; the same offset will be used for
#    every commit without regard to things that change the offset like daylight
#    savings or changes by governing / regulatory organizations.
#
# Portability:
#   Although the syntax and features of the script itself are POSIX-compliant,
#   date(1) is invoked with the "%z" which is specified for strftime(3) but
#   unfortunately not date(1).

BEGIN {
    # Width of the margin on the left that shows messages and hashes. When this
    # is 0, the width is chosen automatically based on the annotation mode.
    MARGIN_WIDTH = 0

    # Controls whether or not line numbers from the working-copy are shown.
    LINE_NUMBERS = 1

    # Controls whether or not line numbers from the original file are shown.
    ORIGINAL_LINE_NUMBERS = 0

    # Timezone to use when displaying date and times:
    # - host: Host's time zone. This is the default.
    # - author: Commit authors time zone.
    # - utc: UTC (+00:00).
    DATETIME = "host"

    # Type of information highlighted in commit annotations. This can be "who",
    # "what" or "when".
    ANNOTATION = "what"

    # When verbose mode is enabled, 2 lines of annotations are shown for every
    # commit (where possible) instead of 1.
    VERBOSE = 1

    # Color palette. The list of palettes can be found under "Predefined Color
    # Palettes."
    PALETTE = "vivid"

    # This number is used as the maximum width of individual expanded tabs.
    TAB_SIZE = 8

    # Color of lines from the boundary commit.
    BOUNDARY_COMMIT_COLOR = "7"

    # Color of lines that have not been committed.
    UNCOMMITTED_COLOR = "239"

    # This variable can be set to invoke "git blame --porcelain" without any
    # post-processing.
    PORCELAIN_PROXY = 0

    # Controls whether time zone offsets are displayed.
    SHOW_TIMEZONE = 0

    # Set script variables and generate Git command.
    GIT_COMMAND = getopts() "; echo '$?='$?"

    # Predefined Color Palettes:

    # - vivd: Very saturated colors of varying hues.
    if (PALETTE == "vivid") {
        BLAME_COLORS = "9 10 11 12 13 14 57 157 166 214"
    # - table: Alternates between a soft purple and gray similar to colors
    #   often used for alternating rows in textbook tables.
    } else if (PALETTE == "table") {
        BLAME_COLORS = "104 245"
    # - mode4: Low-intensity yellow, magenta, green and cyan reminiscent of
    #   early 8-bit hardware color palettes.
    } else if (PALETTE == "mode4") {
        BLAME_COLORS = "2 3 5 6"
    # - red-weak: Palette optimized for red-weak vision.
    } else if (PALETTE == "red-weak") {
        BLAME_COLORS = "1 3 5 9 10 13 14 196 219"
    # - green-weak: Palette optimized for green-weak vision.
    } else if (PALETTE == "green-weak") {
        BLAME_COLORS = "1 3 9 10 13 14 196 219"
    # - blue-weak: Palette optimized for blue-weak vision.
    } else if (PALETTE == "blue-weak") {
        BLAME_COLORS = "9 10 11 13 14 52"
    # - red-blind: Palette optimized for red-blind vision.
    } else if (PALETTE == "red-blind") {
        BLAME_COLORS = "5 10 13 124"
    # - green-blind: Palette optimized for green-blind vision.
    } else if (PALETTE == "green-blind") {
        BLAME_COLORS = "3 14 33 58"
    # - blue-blind: Palette optimized for blue-blind vision.
    } else if (PALETTE == "blue-blind") {
        BLAME_COLORS = "5 6 9 10 52"
    } else {
        abort("unrecognized color palette: " PALETTE)
    }
}

# Write a message to standard error and exit with a non-zero status.
#
# Arguments:
# - text: Message to write to standard error.
#
function abort(text)
{
    print "colorizer:", text > "/dev/fd/2"
    close("/dev/fd/2")
    exit 1
}

# Escape text so it is interpreted as a literal value by POSIX shells.
#
# Arguments:
# - text: Text to escape.
#
# Returns: Escaped text.
#
function shell_escape(text)
{
    gsub(/'/, "'\"'\"'", text)
    return "'" text "'"
}

# Get the value of a command line option and advance OPTIND to the next
# parameter.
#
# Returns: Value associated with an option.
#
function optarg()
{
    if (ARGV[OPTIND] ~ /^-[^-]./) {
        return substr(ARGV[OPTIND++], 3)
    } else if (match(ARGV[OPTIND], "^--[^=]+=")) {
        return substr(ARGV[OPTIND++], RLENGTH + 1)
    } else if ((OPTIND + 1) >= ARGC) {
        abort("missing arg for'" ARGV[OPTIND] "'")
    }

    OPTIND++
    return ARGV[OPTIND++]
}

# Parse parameters in "ARGV" and set the corresponding AWK variables. Values in
# "ARGV" are deleted after being read.
#
# Returns: Git command that outputs porcelain blame data.
#
function getopts(    argument, git, optind0)
{
    git = "git blame --porcelain"

    for (OPTIND = 1; (optind0 = OPTIND) < ARGC; ) {
        if ((argument = ARGV[OPTIND]) == "--") {
            for (; OPTIND < ARGC; git = git " " shell_escape(ARGV[OPTIND++]));
        } else if (argument ~ /^-(m|-margin(=|$))/) {
            MARGIN_WIDTH = optarg()
        } else if (argument ~ /^-N/) {
            LINE_NUMBERS = 0
        } else if (argument ~ /^-(n|-show-number$)/) {
            ORIGINAL_LINE_NUMBERS = 1
        } else if (argument ~ /^-(p|-porcelain)$/) {
            PORCELAIN_PROXY = 1
        } else if (argument ~ /^--palette(=|$)/) {
            PALETTE = optarg()
        } else if (argument ~ /^-(s|-short$)/) {
            VERBOSE = 0
        } else if (argument ~ /^-(u|-utc$)/) {
            DATETIME = "utc"
        } else if (argument ~ /^-(y|-time(=|$))/) {
            DATETIME = optarg()
        } else if (argument ~ /^(who|what|when)$/) {
            ANNOTATION = ARGV[OPTIND]

        # Forward Git-specific short flags that accept arguments. They are
        # parsed by this wrapper so Git's short flags can be combined with this
        # script's short flags.
        } else if (argument ~ /^-L/) {
            git = git " -" substr(argument, 2, 1) " " shell_escape(optarg())

        # Unrecognized options and positional parameters are forwarded to Git.
        } else {
            git = git " " shell_escape(argument)
        }

        # If the argument contains multiple short flags, delete the one that
        # was just processed.
        if (OPTIND == optind0 && argument ~ /^-[^-]./) {
            sub(/[^-]/, "", ARGV[OPTIND])

        # Otherwise, advance the cursor if it wasn't already moved by optarg.
        } else if (OPTIND == optind0) {
            OPTIND++
        }
    }

    return git
}

# Return ANSI or XTerm-compatible escape sequence for displaying a color with
# the given index. If an empty string is passed as an argument to this
# function, the escape sequence for the default terminal color is returned.
# Although it would be more portable to use _tput(1)_ here, hard-coded
# sequences are used for performance reasons since they rarely vary on modern
# emulators.
#
# Arguments:
# - n: Color number.
#
# Return: Terminal escape sequence.
#
function setaf(n)
{
    n = int(n + 0)

    if (n < 8) {
        return "\033[" (n + 30) "m"
    } else if (n < 16) {
        return "\033[" (n + 82) "m"
    } else {
        return "\033[38;5;" n "m"
    }
}

# Convert a Unix timestamp into an ISO 8601-formatted date and time.
#
# Arguments:
# - unixtime: Unix timestamp representing the time to be displayed.
# - tz: Offset from UTC of the time to be displayed. This should be in the form
#   of `/[+-]HHMM/`.
#   returned string.
#
# Returns: A string formatted as specified by ISO 8601.
#
function unix2iso(unixtime, tz,   leap, day, y_end, n, D, HH, M, MM, Y)
{
    unixtime += 3600 * int(tz / 100) + 60 * (tz % 100)
    tz = SHOW_TIMEZONE ? (int(tz) ? tz : "Â±0000") : ""

    Y = 1970
    for (day = leap = y_end = 0; unixtime > y_end; Y += (y_end <= unixtime)) {
        day = int((unixtime - y_end) / 86400) + 1
        leap = (!(Y % 4) && (Y % 100)) || !(Y % 400)
        y_end += (365 + leap) * 86400
    }

    # The value of "n" is the day of the year on which a month ends.
    M = day > (n = 335 + leap) ? 12 : \
        day > (n = 305 + leap) ? 11 : \
        day > (n = 274 + leap) ? 10 : \
        day > (n = 244 + leap) ?  9 : \
        day > (n = 213 + leap) ?  8 : \
        day > (n = 182 + leap) ?  7 : \
        day > (n = 152 + leap) ?  6 : \
        day > (n = 121 + leap) ?  5 : \
        day > (n =  91 + leap) ?  4 : \
        day > (n =  60 + leap) ?  3 : \
        day > (n =  31       ) ?  2 : \
              (n =   0       ) +  1

    D = day - n + 1
    HH = int((unixtime % 86400) / 3600)
    MM = int((unixtime % 3600) / 60)

    return sprintf("%4s-%02d-%02d %02d:%02d", Y, M, D, HH, MM) tz
}

# Truncate text so that it contains no more than "width" characters.
#
# Arguments:
# - text: Text to truncate.
# - width: Maximum number of characters allowed in output.
#
# Returns: String or abbreviated version of the string.
#
function truncate(text, width)
{
    gsub(/[\t ]+$/, "", text)

    if (length(text) <= width) {
        return text
    } else if (MULTIBYTE_SAFE) {
        text = substr(text, 1, width - 1)
        gsub(/[\t ]+$/, "", text)
        return text "â¦"
    } else {
        text = substr(text, 1, width - 3)
        gsub(/[\t ]+$/, "", text)
        return text "..."
    }
}

# Parse a line containing metadata emitted by "git blame --porcelain".
#
function handle_metadata(    i, name, spaces, value)
{
    # The length of column 1 is checked because mawk does not support length
    # quantifier brackets ("...{X,Y}").
    if (/^[0-9a-f]+ [0-9]+ [0-9]+( [0-9]+)?$/ && length($1) >= 40) {
        continuation_of_group = hash == $1
        hash = $1
        original_line = $2
        source_line = $3

        if (NF == 4) {
            group_length = $4
        }

        if (!(hash in commits)) {
            commits[hash] = 1
            commits[hash, "boundary"] = 0
            commits[hash, "color"] = color
        }
    } else {
        name = $1
        value = 1

        if (NF > 1) {
            value = substr($0, length(name) + 2)
            sub(/[ \t]+$/, "", value)

            # Expand tabs to simplify visible width calculations.
            while ((i = index(value, "\t"))) {
                spaces = sprintf("%*s", (TAB_SIZE - ((i - 1) % TAB_SIZE)), "")
                sub(/\t/, spaces, value)
            }
        }

        if (name == "summary" && value == "(" hash ")") {
            value = "No commit summary"
        }

        commits[hash, name] = value
    }
}

# Format two strings as two columns with a maximum width of "MARGIN_WIDTH". If
# the total length of both columns exceeds "MARGIN_WIDTH", the left column will
# be truncated.
#
# Arguments:
# - left: Text in left column.
# - right: Text in right column.
#
# Returns: Line of text formatted as two columns.
#
function format_columns(left, right,    n)
{
    left = truncate(left, MARGIN_WIDTH - length(right))
    for (n = MARGIN_WIDTH - length(left) - length(right); n > 0; n--) {
        left = left " "
    }

    return left right
}

# Generate annotations for the current commit.
#
function annotate(    clock, date, name, offset, rightcol)
{
    name = commits[hash, "author"]
    if (!length(name)) {
        name = commits[hash, "author-mail"]
    }

    offset = OUTPUT_TIMEZONE
    if (!length(offset)) {
        offset = commits[hash, "author-tz"]
    }

    clock = unix2iso(commits[hash, "author-time"], offset)

    # Line 1: Author name or email address.
    # Line 2: Date and the commit summary.
    # Brief: Author name (or email address) and the commit summary.
    if (ANNOTATION == "who") {
        date = substr(clock, 1, 10)
        margins[1] = name
        margins[2] = date ": " commits[hash, "summary"]
        margins["brief"] = format_columns(name, " (" date ")")

    # Line 1: Commit summary and the short hash if it fits on the same line.
    # Line 2: Date & time and the author's name or a medium hash if the short
    # hash was not displayed on the first line.
    # Brief: Commit summary truncated as needed and the short hash.
    } else if (ANNOTATION == "what") {
        rightcol = " (" substr(hash, 1, 7) ")"
        margins["brief"] = format_columns(commits[hash, "summary"], rightcol)

        # If the summary is short enough, display it with the short hash on the
        # first margin line then display the time and author on the second
        # line.
        if ((MARGIN_WIDTH - \
          length(commits[hash, "summary"]) - length(rightcol)) >= 0) {
            margins[1] = margins["brief"]
            margins[2] = clock " - " name

        # Otherwise, display a truncated commit summary on the first line
        # then display the time and medium hash on the second line.
        } else {
            margins[1] = commits[hash, "summary"]
            margins[2] = clock " - " substr(hash, 1, 13)
        }

    # Line 1 and brief: Date & time.
    } else if (ANNOTATION == "when") {
        margins["brief"] = substr(clock, 1, MARGIN_WIDTH)
        margins[1] = margins["brief"]
        margins[2] = ""
    }

    if (!VERBOSE) {
        margins[1] = margins["brief"]
        margins[2] = ""
    }
}

# Display a line of source code emitted by "git blame --porcelain".
#
function handle_line(    c, furthest, lineno, margin, previous_color)
{
    margin = ""

    if (LINE_NUMBERS && ORIGINAL_LINE_NUMBERS) {
        lineno = sprintf("%6d  %6d  ", original_line, source_line)
    } else if (LINE_NUMBERS) {
        lineno = sprintf("%6d  ", source_line)
    } else if (ORIGINAL_LINE_NUMBERS) {
        lineno = sprintf("%6d  ", original_line)
    } else {
        lineno = "  "
    }

    $0 = lineno substr($0, 2)

    # The porcelain format treats discontinuities between line numbers in the
    # original file as separate groups even if the lines all come from one
    # commit; for example:
    #
    #   [...]
    #   498b29f4a84bfb87192d0e5b736c1150feb2773b 130 130
    #                   git blame "$@"
    #   7c6a9aa87d265ad0460a29c1e14dc23911f76e49 199 131 1
    #               fi
    #   7c6a9aa87d265ad0460a29c1e14dc23911f76e49 202 132 2
    #           }
    #   7c6a9aa87d265ad0460a29c1e14dc23911f76e49 203 133
    #   [...]
    #
    # Although lines 131 and 132 come from the same commit, Git treats them as
    # different groups hence the 4th field on both lines and the reason for the
    # "continuation_of_group" guarding the overflow logic.
    if (length(overflow_buffer) && !continuation_of_group) {
        # If there's a line in the overflow buffer and the current group does
        # not have any annotations, the previous group's annotations are
        # allowed to spill into the otherwise empty margins.
        if (commits[hash, "boundary"] || hash == HASH_OF_UNCOMMITTED_BLOCK) {
            printf FORMAT, COLORS[color], margins[1], overflow_buffer
            printf FORMAT, COLORS[color], margins[2], ""

            color = commits[hash, "boundary"] ? "boundary" : "uncommitted"

            print COLORS[color] $0 COLORS["reset"]
            overflow_buffer = ""
            return
        }

        # If the current group also has annotations, use the brief, one-line
        # annotation for the previous group.
        printf FORMAT, COLORS[color], margins["brief"], overflow_buffer
    }

    if (commits[hash, "boundary"]) {
        color = "boundary"

    } else if (hash == HASH_OF_UNCOMMITTED_BLOCK) {
        color = "uncommitted"

    } else if (continuation_of_group) {
        if (length(overflow_buffer)) {
            printf FORMAT, COLORS[color], margins[1], overflow_buffer
        }

        color_locations[color] = source_line
        margin = margins[2]
        margins[2] = ""

    } else {
        annotate()
        margins[1] = truncate(margins[1], MARGIN_WIDTH)
        margins[2] = truncate(margins[2], MARGIN_WIDTH)

        # Reuse the most recently displayed color for the current hash if it
        # has not been used by another hash in the mean time.
        previous_color = commits[hash, "color"]
        if (previous_color != color &&
          commits[hash, "last_line"] == color_locations[previous_color]) {
            color = previous_color

        # Otherwise, pick whichever color was least-recently used.
        } else {
            furthest = INFINITY
            for (c = 1; c <= COLOR_COUNT; c++) {
                if (c != color && color_locations[c] < furthest) {
                    furthest = color_locations[c]
                    commits[hash, "color"] = color = c
                }
            }
        }

        color_locations[color] = source_line

        # If the current group's annotation has two lines but the group is only
        # one line long, add the would-be printed line to the overflow buffer.
        if (length(margins[2]) && group_length == 1) {
            overflow_buffer = $0 COLORS["reset"] "\n"
            commits[hash, "last_line"] = source_line
            return
        }

        margin = margins[1]
    }

    overflow_buffer = ""
    commits[hash, "last_line"] = source_line
    printf FORMAT, COLORS[color], margin, $0 COLORS["reset"] "\n"
}

BEGIN {
    if (PORCELAIN_PROXY) {
        exit system(GIT_COMMAND)
    }

    if (DATETIME == "host") {
        command = "date +%z"
        command | getline OUTPUT_TIMEZONE
        close(command)
    } else if (DATETIME == "utc") {
        OUTPUT_TIMEZONE = "0000"
    } else if (DATETIME == "author") {
        SHOW_TIMEZONE = 1
        OUTPUT_TIMEZONE = ""
    } else {
        abort("unrecognized date timezone: " DATETIME)
    }

    if (ANNOTATION == "who") {
        MARGIN_WIDTH = MARGIN_WIDTH > 0 ? MARGIN_WIDTH : 25
    } else if (ANNOTATION == "what") {
        MARGIN_WIDTH = MARGIN_WIDTH > 0 ? MARGIN_WIDTH : 50
    } else if (ANNOTATION == "when") {
        MARGIN_WIDTH = MARGIN_WIDTH > 0 ? MARGIN_WIDTH : length(unix2iso(0, 0))
    } else {
        abort("unrecognized annotation mode: " ANNOTATION)
    }

    HASH_OF_UNCOMMITTED_BLOCK = "0000000000000000000000000000000000000000"
    INFINITY = 999999

    COLOR_COUNT = split(BLAME_COLORS, COLORS)
    COLORS["boundary"] = setaf(BOUNDARY_COMMIT_COLOR)
    COLORS["uncommitted"] = setaf(UNCOMMITTED_COLOR)
    COLORS["reset"] = "\033[m"
    FORMAT = "%s%-" MARGIN_WIDTH "s%s"
    MULTIBYTE_SAFE = length("å®½") == 1

    color = 1
    hash = ""
    overflow_buffer = ""

    for (k = 1; k <= COLOR_COUNT; k++) {
        color_locations[k] = -INFINITY
        COLORS[k] = setaf(COLORS[k])
    }

    while ((GIT_COMMAND | getline)) {
        if (/^\$\?=[0-9]+$/) {
            if (length(overflow_buffer)) {
                printf FORMAT, COLORS[color], margins["brief"], overflow_buffer
            }
            close(GIT_COMMAND)
            exit substr($0, 4)
        } else if (/^\t/) {
            handle_line()
        } else {
            handle_metadata()
        }
    }

    exit 1
}
