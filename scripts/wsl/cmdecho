#!/usr/bin/env python3
"""
Usage: cmdecho TEXT...

Replace anything that appears to be a Windows-style environment variable then
echo the resulting text. This is similar to "echo" command when executing
cmd.exe.

Examples:
  cmdecho "%USERPROFILE%"
  cmdecho "SystemRoot=%SystemRoot%"
"""
import os
import re
import sys

# The tokenization regex is designed so that, in syntactically valid file,
# there will be no gaps between matches, so invalid syntax can be detected by
# looking for gaps between matches.
POSIX_SHELL_TOKENIZER_RE = re.compile(
    r"""
    '[^']*'           | # Single quoted strings have no escapes
    "(?:[^"\\]|\\.)*" | # Double quoted strings support "\" for literal values
    \\.               | # Escaped literals can appear outside of quotes.
    [^\s'";\\]+       | # Bare tokens include any printable non-meta characters
    \s*(?:[\n;]|\s+)  | # Line breaks and semicolons delimit commands
    \s+                 # Whitespace delimits words
    """,
    re.DOTALL | re.VERBOSE
)


def split_commands(text):
    """
    Split a POSIX-shell-like script into individual commands respecting
    newlines, semicolons and quoting.

    Arguments:
    - text

    Return: A list of lists. Each inner list represents a command followed by
    any arguments.
    """
    entries = [[]]
    argument_tokens = list()
    previous_end = 0

    for match in POSIX_SHELL_TOKENIZER_RE.finditer(text):
        if match.start(0) != previous_end:
            lineno = text[:match.start(0)].count("\n") + 1
            raise Exception(f"Syntax error on or after line {lineno}")

        previous_end = match.end(0)
        token = match.group(0)

        if token[0] == "'":
            argument_tokens.append(token[1:-1])
        elif token[0] == '"':
            argument_tokens.append(token[1:-1].replace("\\", ""))
        elif token[0] == "\\":
            argument_tokens.append(token[1])
        elif ";" in token or "\n" in token:
            if argument_tokens:
                entries[-1].append("".join(argument_tokens))
                del argument_tokens[:]

            if entries[-1]:
                entries.append([])
        elif not token[0].isspace():
            argument_tokens.append(token)
        elif argument_tokens:
            argument = "".join(argument_tokens)
            entries[-1].append(argument)
            del argument_tokens[:]

    if argument_tokens:
        entries[-1].append("".join(argument_tokens))
    elif not entries[-1]:
        del entries[-1]

    return entries


def main(argv):
    strings = argv[1:]

    if not strings:
        print(f"Usage: {os.path.basename(argv[0])} TEXT...", file=sys.stderr)
        return 1

    variables = {}
    windows_env_file = os.environ.get("WINDOWS_ENV_FILE")

    if windows_env_file:
        try:
            with open(windows_env_file) as fd:
                contents = fd.read().strip()
        except FileNotFoundError:
            contents = ""

        for argv in split_commands(contents):
            if len(argv) == 1 and "=" in argv[0]:
                name, value = argv[0].split("=", 1)
                name = name.lower()
                variables[name] = value

    if variables:
        pattern = re.compile(
            f"%({'|'.join(map(re.escape, variables))})%", re.IGNORECASE
        )

        for index, string in enumerate(strings):
            strings[index] = pattern.sub(
                lambda x: variables[x.group(0).lower()[1:-1]], string
            )

    print(*strings)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
