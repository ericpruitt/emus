#!/usr/bin/mawk -f
# This script is designed to be used with Vim's "formatprg" option. It reads
# text from standard input, formats the text and writes the text to standard
# output. In addition to formatting plain text files, the script also supports
# formatting code that uses C/C++ style comments (i.e. "//..." and "/* ... */")
# and comment-only lines denoted with "#".
#
# User-specifiable variables:
#
# - FORMAT: Format of the text in the file being edited. The valid values for
#   this are "c", "generic" and "plain:"
#   - c: text file that supports C/C++ style comments. The format internally
#     falls back to "plain" if the first non-blank line does not begin with a
#     C/C++ style comment so blocks of text inside of /* ... */ without leading
#     asterisks (*) on each line can be wrapped like a normal, plain-text file
#     which is likely what most users want to happen. If the first non-blank
#     line of the input is a comment, all of the following lines that are not
#     comment are left unchanged.
#   - generic: text file supports comments marked by a spaces and then a
#     certain string of characters. The supported comment strings are "#",
#     "--", "//", ";" and '"'. The string used for comments is automatically
#     detected, and lines that do not match the expected comment format are
#     left unchanged.
#   - plain: text file format that does not support comments.
#
# - TAB_SIZE: Leading tabs will be expanded to the number of spaces specified
#   in this variable. If this value is less than 1, it will be set to 1.
# - TEXT_WIDTH: Last column that may contain printable characters. This
#   defaults to 79.
#
# These variables are set using awk's "-v" option. In the following example,
# the text width is set to 72 and the comment format to C/C++:
#
#   vifmt -v TEXT_WIDTH=72 -v FORMAT=c
#
# This script is POSIX-Awk compatible, but mawk is used in the shebang line
# since it tends to be faster than gawk which is often symlinked from
# .../bin/awk on Linux systems.
#
# This script works similarly to Vim's built-in formatting, but it supports
# wrapping text with two columns, specifically for formatting command line tool
# usage information, and it also supports list-specific wrapping inside of
# source code comments.
#
# TODO:
# - Markdown support to make it possible to filter an entire document through
#   this script and have it gracefully handle things like headers, code blocks
#   and avoid putting words inside of link brackets on separate lines.
BEGIN {
    if (FORMAT !~ /^(c|generic|plain)$/) {
        print "vifmt: unrecognized format: " FORMAT > (stderr = "/dev/fd/2")
        close(stderr)
        exit 1
    }

    # Currently only used to match "-" lists but may be expanded later.
    LEADER_REGEX = "^ *- "

    TOKEN_TO_FORMAT["/*"]   = "c"
    TOKEN_TO_FORMAT["/**"]  = "c"

    TOKEN_TO_FORMAT["#"]    = "generic"         # Shell, AWK, Python, etc.
    TOKEN_TO_FORMAT["--"]   = "generic"         # SQL
    TOKEN_TO_FORMAT["//"]   = "generic"         # Go
    TOKEN_TO_FORMAT[";"]    = "generic"         # Assembly, INI files
    TOKEN_TO_FORMAT["\""]   = "generic"         # Vim

    USAGE_BODY = 1
    USAGE_FIRST_PARAGRAPH = -1

    # Lowercase forms of these words words are ignored as long as when
    # assessing if a given string is a title as long as they are not the first
    # word.
    TITLE_CASE_IGNORED_REGEX = "( (" \
        "a|is|and|for|to|the|for|nor|but|so|by|as|in|out|per|at|via" \
    ")( |$))+"

    TEXT_WIDTH = int(0 + TEXT_WIDTH)
    if (TEXT_WIDTH < 1) {
        TEXT_WIDTH = 79
    }

    TAB_SIZE = int(0 + TAB_SIZE)
    if (TAB_SIZE < 1) {
        TAB_SIZE = 8
    }

    buffer = ""
    buffer_comment = ""
    is_usage = 0
}

function wrap(text, margin,    c, columns, eol, leader, cfix, n, pad, width)
{
    leader = ""
    cfix = FORMAT == "c" ? index(margin, "/*") : 0
    pad = ""

    if (match(text, /^[ \t]+/)) {
        pad = substr(text, RSTART, RLENGTH)
        text = substr(text, RSTART + RLENGTH)
    }

    # Detect lists denoted with "-"
    if (index(text, "- ") == 1) {
        leader = "- "

    # Detect blocks of text with two columns
    } else if (match(text, /  ([^ ] |[^ ][^ ])+  +/)) {
        leader = substr(text, 1, RSTART + RLENGTH - 1)
    } else if (match(text, /  +/)) {
        leader = substr(text, 1, RSTART + RLENGTH - 1)
    }

    if (length(leader)) {
        text = substr(text, length(leader) + 1)
    }

    n = split(text, columns)
    leader = pad leader
    eol = TEXT_WIDTH - length(leader) - length(margin)
    if (match(pad, /^\t+/)) {
        eol -= (TAB_SIZE - 1) * RLENGTH
    }

    width = 0

    for (c = 1; c <= n; c++) {
        if (!width && length(columns[c]) >= eol) {
            print margin leader columns[c]
        } else {
            width = width + length(columns[c])
            if (c == 1 || width >= eol) {
                width = length(columns[c])
                if (c != 1) {
                    print ""
                }
                printf "%s", margin leader columns[c]
            } else {
                width = width + 1
                printf " %s", columns[c]
            }
            if (c == n) {
                print ""
            }
        }

        if (cfix) {
            cfix = 0
            sub("/", " ", margin)
        }

        # The original contents of the leader are only shown for the first
        # line of wrapped text. After that, it becomes a set of spaces to align
        # subsequent lines.
        gsub(/[^ \t]/, " ", leader)
    }
}

function is_title(text)
{
    gsub(TITLE_CASE_IGNORED_REGEX, " ", text)
    return text ~ /^[ ]*[A-Z][^ \t]*( [A-Z][^ \t]*)*$/
}

{
    if (FORMAT != "plain" && !length(COMMENT_REGEX) && NF) {
        if (FORMAT == "c" || ((guess = TOKEN_TO_FORMAT[$1]) == "c")) {
            if (FORMAT == "c" && $1 !~ /^(\/\*\*?|\*|\/\/)$/) {
                FORMAT = "plain"
            } else {
                COMMENT_REGEX = "^([ \t]*/?(\\*|//)( |$))"
                FORMAT = (FORMAT == "c") ? FORMAT : guess
            }
        } else if (guess) {
            COMMENT_REGEX = "^[ \t]*" $1 "( |$)"
        } else {
            print
            next
        }
    }

    text = $0
    comment = ""

    if (length(COMMENT_REGEX) && match(text, COMMENT_REGEX)) {
        comment = substr(text, RSTART, RLENGTH)
        text = substr(text, RSTART + RLENGTH)
        if (substr(comment, length(comment), 1) != " ") {
            comment = comment " "
        }

        if ((comment != buffer_comment) && !length(buffer_comment)) {
            buffer_comment = comment
            is_usage = (is_usage == USAGE_FIRST_PARAGRAPH) ? is_usage : 0
        }
    } else if (buffer_comment) {
        wrap(buffer, buffer_comment)
        buffer = ""
        buffer_comment = ""

        # For C/C++ style block comments, "/*" should only be used for the
        # first line.
        if (FORMAT == "c" && index(buffer_comment, "/*")) {
            sub(/\//, " ", buffer_comment)
        }
    }

    sub(/[ \t]+$/, "", text)
    is_blank = !length(text)
    verbatim = length(COMMENT_REGEX) && !length(comment)
    reset = 0

    # When processing usage information in a file that contains comments, stop
    # assuming text is part of the usage information upon reaching the first
    # blank or uncommented line.
    if (is_usage == USAGE_BODY && FORMAT != "plain" && (!NF || verbatim)) {
        is_usage = 0
    }

    # The first paragraph of a usage block is reprinted verbatim.
    if (!is_usage && index(text, "Usage:") == 1) {
        is_usage = USAGE_FIRST_PARAGRAPH
        verbatim = 1
    } else if (is_usage == USAGE_FIRST_PARAGRAPH) {
        if (is_blank) {
            is_usage = 1
        } else {
            verbatim = 1
        }

    } else if (is_usage && !is_blank) {
        # A line with two columns marks the beginning of a new block of lines.
        if (match(text, /[^ \t]  +[^ \t]/)) {
            edge = RSTART + RLENGTH - 1
            reset = 1
        # A change in indent level marks the beginning of a new block.
        } else if (match(text, /^[ \t]*/)) {
            this_edge = RSTART + RLENGTH
            reset = this_edge != edge
            edge = this_edge
        }

        if ((colon = index(text, ":"))) {
            # Lines that appear to be section titles are reprinted verbatim.
            verbatim = verbatim || (colon == length(text) ? is_title(text) : 0)
            # Lines that appear to be metadata (things like "Author: ...",
            # "License: ...", etc.) mark the beginning of a new block.
            reset = reset || verbatim || is_title(substr(text, 1, colon - 1))
        }
    }

    if (is_blank || verbatim || reset || match(text, LEADER_REGEX)) {
        wrap(buffer, buffer_comment)
        buffer = ""

        # For C/C++ style block comments, "/*" should only be used for the
        # first line.
        if (FORMAT == "c" && index(buffer_comment, "/*")) {
            sub(/\//, " ", buffer_comment)
        }
    }

    if (verbatim) {
        print
    } else if (is_blank) {
        gsub(/[ \t]+$/, "", comment)
        print comment
    } else if (length(buffer)) {
        gsub(/^[ \t]+|[ \t]+$/, "", text)
        buffer = buffer " " text
    } else {
        buffer = text
    }
}

END {
    if (length(buffer)) {
        wrap(buffer, buffer_comment)
    }
}
