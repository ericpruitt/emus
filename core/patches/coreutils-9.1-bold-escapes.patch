Add support for a new _cat(1)_ option, "--bold-escapes", that makes escape
sequences generated by "-E", "-v" and "-T" bold making it easy to determine
which strings are literal sequences in the input and which strings represent
escaped characters. The "--bold-escapes" option is ignored if "-v" is not
specified since it may conflict with escape sequences present in the input.

--- src/cat.c	2022-04-08 04:22:17.000000000 -0700
+++ src/cat.c	2022-07-30 22:25:12.506885948 -0700
@@ -42,6 +42,7 @@
 #include "full-write.h"
 #include "safe-read.h"
 #include "xbinary-io.h"
+#include "argmatch.h"
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "cat"
@@ -50,6 +51,9 @@
   proper_name ("Torbjorn Granlund"), \
   proper_name ("Richard M. Stallman")
 
+#define TTY_BOLD "\033[1m"
+#define TTY_SGR0 "\033[0m"
+
 /* Name of input file.  May be "-".  */
 static char const *infile;
 
@@ -83,6 +87,29 @@
 /* Whether there is a pending CR to process.  */
 static bool pending_cr = false;
 
+enum
+  {
+    BOLD_ESCAPES_OPTION = CHAR_MAX + 1,
+  };
+
+enum bold_type
+  {
+    bold_never,
+    bold_always,
+    bold_auto,
+  };
+
+static char const *const bold_args[] =
+  {
+    "always", "never", "auto", NULL
+  };
+
+static enum bold_type const bold_types[] =
+  {
+    bold_always, bold_never, bold_auto
+  };
+ARGMATCH_VERIFY (bold_args, bold_types);
+
 void
 usage (int status)
 {
@@ -104,6 +131,11 @@
 \n\
   -A, --show-all           equivalent to -vET\n\
   -b, --number-nonblank    number nonempty output lines, overrides -n\n\
+  --bold-escapes[=WHEN]    make escape sequences generated by -E, -v and -T\n\
+                           bold. WHEN can be 'always' (default if omitted),\n\
+                           'auto' or 'never'. This option is ignored if -v\n\
+                           is not specified since it may conflict with\n\
+                           escape sequences present in the input.\n\
   -e                       equivalent to -vE\n\
   -E, --show-ends          display $ at end of each line\n\
   -n, --number             number all output lines\n\
@@ -214,7 +246,7 @@
 static bool
 cat (char *inbuf, idx_t insize, char *outbuf, idx_t outsize,
      bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank,
-     bool show_ends, bool squeeze_blank)
+     bool show_ends, bool squeeze_blank, bool bold_escapes)
 {
   /* Last character read from the input buffer.  */
   unsigned char ch;
@@ -373,6 +405,9 @@
               /* Output a currency symbol if requested (-e).  */
               if (show_ends)
                 {
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_BOLD);
+
                   if (pending_cr)
                     {
                       *bpout++ = '^';
@@ -380,6 +415,9 @@
                       pending_cr = false;
                     }
                   *bpout++ = '$';
+
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_SGR0);
                 }
 
               /* Output the newline.  */
@@ -414,13 +452,19 @@
          scan for chars that need conversion.  */
       if (show_nonprinting)
         {
-          while (true)
+          for (;; ch = *bpin++)
             {
               if (ch >= 32)
                 {
-                  if (ch < 127)
+                  if (ch < 127) {
                     *bpout++ = ch;
-                  else if (ch == 127)
+                    continue;
+                  }
+
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_BOLD);
+
+                  if (ch == 127)
                     {
                       *bpout++ = '^';
                       *bpout++ = '?';
@@ -445,6 +489,9 @@
                           *bpout++ = ch - 128 + 64;
                         }
                     }
+
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_SGR0);
                 }
               else if (ch == '\t' && !show_tabs)
                 *bpout++ = '\t';
@@ -455,11 +502,15 @@
                 }
               else
                 {
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_BOLD);
+
                   *bpout++ = '^';
                   *bpout++ = ch + 64;
-                }
 
-              ch = *bpin++;
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_SGR0);
+                }
             }
         }
       else
@@ -469,8 +520,14 @@
             {
               if (ch == '\t' && show_tabs)
                 {
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_BOLD);
+
                   *bpout++ = '^';
                   *bpout++ = ch + 64;
+
+                  if (bold_escapes)
+                    bpout = stpcpy(bpout, TTY_SGR0);
                 }
               else if (ch != '\n')
                 {
@@ -544,6 +601,7 @@
   struct stat stat_buf;
 
   /* Variables that are set according to the specified options.  */
+  bool bold_escapes = false;
   bool number = false;
   bool number_nonblank = false;
   bool squeeze_blank = false;
@@ -561,6 +619,7 @@
     {"show-ends", no_argument, NULL, 'E'},
     {"show-tabs", no_argument, NULL, 'T'},
     {"show-all", no_argument, NULL, 'A'},
+    {"bold-escapes", optional_argument, NULL, BOLD_ESCAPES_OPTION},
     {GETOPT_HELP_OPTION_DECL},
     {GETOPT_VERSION_OPTION_DECL},
     {NULL, 0, NULL, 0}
@@ -581,6 +640,7 @@
   /* Parse command line options.  */
 
   int c;
+  int bold_arg;
   while ((c = getopt_long (argc, argv, "benstuvAET", long_options, NULL))
          != -1)
     {
@@ -631,6 +691,19 @@
           show_tabs = true;
           break;
 
+        case BOLD_ESCAPES_OPTION:
+          if (optarg)
+            {
+              bold_arg = XARGMATCH ("--bold-escapes", optarg, bold_args,
+                                    bold_types);
+              bold_escapes = bold_arg == bold_always ||
+                             (bold_arg == bold_auto && isatty(STDOUT_FILENO));
+            }
+          else
+            bold_escapes = true;
+
+          break;
+
         case_GETOPT_HELP_CHAR;
 
         case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
@@ -640,6 +713,9 @@
         }
     }
 
+  if (bold_escapes && !show_nonprinting)
+    bold_escapes = false;
+
   /* Get device, i-node number, and optimal blocksize of output.  */
 
   if (fstat (STDOUT_FILENO, &stat_buf) < 0)
@@ -767,8 +843,14 @@
              Align the output buffer to a page size boundary, for efficiency
              on some paging implementations.  */
 
+          int inflation_factor = 4;
+
           idx_t bufsize;
-          if (INT_MULTIPLY_WRAPV (insize, 4, &bufsize)
+
+          if (bold_escapes)
+            inflation_factor += strlen(TTY_BOLD) + strlen(TTY_SGR0);
+
+          if (INT_MULTIPLY_WRAPV (insize, inflation_factor, &bufsize)
               || INT_ADD_WRAPV (bufsize, outsize, &bufsize)
               || INT_ADD_WRAPV (bufsize, LINE_COUNTER_BUF_LEN - 1, &bufsize))
             xalloc_die ();
@@ -776,7 +858,7 @@
 
           ok &= cat (inbuf, insize, outbuf, outsize, show_nonprinting,
                      show_tabs, number, number_nonblank, show_ends,
-                     squeeze_blank);
+                     squeeze_blank, bold_escapes);
 
           alignfree (outbuf);
         }
