Title: Restrict Mouse To Focused Monitor
Author: Eric Pruitt (https://www.codevat.com/, https://github.com/ericpruitt/)

This change adds the option to restrict the mouse to the focused monitor. When
the mouse reaches the edge of the screen while restriction is enabled, the
cursor will not be permitted to move to another monitor. This feature is
controlled by the variable "restrictmouse" which should be defined in the
configuration header i.e. `static int restrictmouse = 1`. When mouse
restriction is enabled, the behavior of "focusmon" changes so that it warps the
mouse to the newly focused monitor.

diff --git dwm.c dwm.c
index d27cb67..3a30a38 100644
--- dwm.c
+++ dwm.c
@@ -120,6 +120,7 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	int lx, ly;           /* relative position of mouse when last focused */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -196,2 +197,3 @@ static void restack(Monitor *m);
 static void run(void);
+static void restrictmousetoggle(const Arg *arg);
 static void scan(void);
@@ -270,1 +272,2 @@ static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
+static int overriderestrictmouse = 0;
@@ -638,6 +641,8 @@ createmon(void)
 	m->topbar = topbar;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+	m->lx = 0;
+	m->ly = 0;
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
 	return m;
 }
@@ -818,6 +823,12 @@ void
 focusmon(const Arg *arg)
 {
 	Monitor *m;
+	int x, y;
+
+	if (getrootptr(&x, &y)) {
+		selmon->lx = x - selmon->mx;
+		selmon->ly = y - selmon->my;
+	}
 
 	if (!mons->next)
 		return;
@@ -827,6 +838,13 @@ focusmon(const Arg *arg)
 					in gedit and anjuta */
 	selmon = m;
 	focus(NULL);
+
+	if (restrictmouse) {
+		// XXX: I don't think it's gauranteed that the next XEvent will
+		// be the MotionNotify generated by this XWarpPointer call.
+		overriderestrictmouse = 1;
+		XWarpPointer(dpy, None, root, 0, 0, 0, 0, m->lx + m->mx, m->ly + m->my);
+	}
 }
 
 void
@@ -1123,15 +1141,46 @@ motionnotify(XEvent *e)
 	static Monitor *mon = NULL;
 	Monitor *m;
 	XMotionEvent *ev = &e->xmotion;
+	int clipped = 2;
 
 	if (ev->window != root)
 		return;
 	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+		if (!restrictmouse || overriderestrictmouse) {
+			goto switch_monitor;
+		}
+
+		if (ev->x_root >= (mon->mx + mon->mw)) {
+			ev->x_root = mon->mx + mon->mw - 1;
+		} else if (ev->x_root < mon->mx) {
+			ev->x_root = mon->mx;
+		} else {
+			clipped--;
+		}
+
+		if (ev->y_root >= (mon->my + mon->mh)) {
+			ev->y_root = mon->my + mon->mh - 1;
+		} else if (ev->y_root < mon->my) {
+			ev->y_root = mon->my;
+		} else {
+			clipped--;
+		}
+
+		if (clipped > 0 && XWarpPointer(dpy, None, root, 0, 0, 0, 0, ev->x_root, ev->y_root)) {
+			return;
+		}
+
+switch_monitor:
 		unfocus(selmon->sel, 1);
 		selmon = m;
 		focus(NULL);
 	}
 	mon = m;
+	if (mon) {
+		mon->lx = ev->x_root - mon->mx;
+		mon->ly = ev->y_root - mon->my;
+	}
+	overriderestrictmouse = 0;
 }
 
 void
@@ -1375,6 +1424,12 @@ restack(Monitor *m)
 }
 
 void
+restrictmousetoggle(const Arg *arg)
+{
+	restrictmouse = !restrictmouse;
+}
+
+void
 run(void)
 {
 	XEvent ev;
@@ -1890,6 +1945,8 @@ updategeom(void)
 					m->my = m->wy = unique[i].y_org;
 					m->mw = m->ww = unique[i].width;
 					m->mh = m->wh = unique[i].height;
+					m->lx = m->mw / 2;
+					m->ly = m->mh / 2;
 					updatebarpos(m);
 				}
 		} else {
